<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Predicates — GoQDSL</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>

<header class="site-header">
  <a href="index.html" class="logo">Go<span>QDSL</span></a>
  <span class="tagline">Fluent SQL Query Builder for Go + PostgreSQL</span>
</header>

<div class="layout">

<aside class="sidebar">
  <nav>
    <div class="nav-section">Getting Started</div>
    <a href="index.html">Overview</a>
    <div class="nav-section">Query Builders</div>
    <a href="select.html">SELECT</a>
    <a href="insert.html">INSERT</a>
    <a href="update.html">UPDATE</a>
    <a href="delete.html">DELETE</a>
    <div class="nav-section">Core Concepts</div>
    <a href="predicates.html" class="active">Predicates</a>
    <a href="execution.html">Execution &amp; DB</a>
  </nav>
</aside>

<main class="content">

  <h1>Predicates</h1>
  <p class="lead">
    Predicates are the building blocks for WHERE, HAVING, and any other
    conditional clause. GoQDSL provides 15 composable predicate types that
    generate parameterized SQL fragments.
  </p>

  <!-- ── Interface ─────────────────────────────────── -->

  <h2 id="interface">The Predicate Interface</h2>

  <div class="sig">
    <code><span class="kw">type</span> <span class="typ">Predicate</span> <span class="kw">interface</span> {
    <span class="fn">ToSQL</span>(offset <span class="typ">int</span>) (sql <span class="typ">string</span>, args []<span class="typ">any</span>, newOffset <span class="typ">int</span>)
}</code>
  </div>

  <p>
    Every predicate can render itself as a parameterized SQL fragment.
    The <code>offset</code> parameter is the next available placeholder
    number (<code>$1</code>, <code>$2</code>, &hellip;). The method returns:
  </p>
  <ul>
    <li><code>sql</code> &mdash; the SQL fragment (e.g. <code>name = $3</code>)</li>
    <li><code>args</code> &mdash; the values consumed by this predicate</li>
    <li><code>newOffset</code> &mdash; the next available placeholder number after this predicate</li>
  </ul>

  <div class="note">
    You normally don't call <code>ToSQL</code> directly. Instead, pass
    predicates to <code>Where()</code> or <code>Having()</code> on a
    builder, which handles offset tracking automatically.
  </div>

  <!-- ── Comparison ────────────────────────────────── -->

  <h2 id="comparison">Comparison Predicates</h2>

  <table>
    <thead>
      <tr><th>Function</th><th>SQL Output</th><th>Description</th></tr>
    </thead>
    <tbody>
      <tr>
        <td><code>Eq(col, val)</code></td>
        <td><code>col = $N</code></td>
        <td>Equal</td>
      </tr>
      <tr>
        <td><code>Neq(col, val)</code></td>
        <td><code>col != $N</code></td>
        <td>Not equal</td>
      </tr>
      <tr>
        <td><code>Gt(col, val)</code></td>
        <td><code>col > $N</code></td>
        <td>Greater than</td>
      </tr>
      <tr>
        <td><code>Gte(col, val)</code></td>
        <td><code>col >= $N</code></td>
        <td>Greater than or equal</td>
      </tr>
      <tr>
        <td><code>Lt(col, val)</code></td>
        <td><code>col < $N</code></td>
        <td>Less than</td>
      </tr>
      <tr>
        <td><code>Lte(col, val)</code></td>
        <td><code>col <= $N</code></td>
        <td>Less than or equal</td>
      </tr>
    </tbody>
  </table>

  <h3 id="eq">Eq</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">Eq</span>(col <span class="typ">string</span>, val <span class="typ">any</span>) <span class="typ">Predicate</span></code>
  </div>

<pre><code>goqdsl.<span class="fn">Select</span>(<span class="str">"*"</span>).<span class="fn">From</span>(<span class="str">"users"</span>).<span class="fn">Where</span>(goqdsl.<span class="fn">Eq</span>(<span class="str">"name"</span>, <span class="str">"Alice"</span>))
<span class="cmt">// WHERE name = $1    args: ["Alice"]</span></code></pre>

  <h3 id="neq">Neq</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">Neq</span>(col <span class="typ">string</span>, val <span class="typ">any</span>) <span class="typ">Predicate</span></code>
  </div>

<pre><code>goqdsl.<span class="fn">Neq</span>(<span class="str">"status"</span>, <span class="str">"deleted"</span>)
<span class="cmt">// status != $N</span></code></pre>

  <h3 id="gt">Gt / Gte / Lt / Lte</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">Gt</span>(col <span class="typ">string</span>, val <span class="typ">any</span>) <span class="typ">Predicate</span>
<span class="kw">func</span> <span class="fn">Gte</span>(col <span class="typ">string</span>, val <span class="typ">any</span>) <span class="typ">Predicate</span>
<span class="kw">func</span> <span class="fn">Lt</span>(col <span class="typ">string</span>, val <span class="typ">any</span>) <span class="typ">Predicate</span>
<span class="kw">func</span> <span class="fn">Lte</span>(col <span class="typ">string</span>, val <span class="typ">any</span>) <span class="typ">Predicate</span></code>
  </div>

<pre><code>goqdsl.<span class="fn">Select</span>(<span class="str">"*"</span>).<span class="fn">From</span>(<span class="str">"users"</span>).<span class="fn">Where</span>(
    goqdsl.<span class="fn">Gte</span>(<span class="str">"age"</span>, 18),
    goqdsl.<span class="fn">Lt</span>(<span class="str">"age"</span>, 65),
)
<span class="cmt">// WHERE age >= $1 AND age < $2    args: [18, 65]</span></code></pre>

  <!-- ── Pattern ───────────────────────────────────── -->

  <h2 id="pattern">Pattern Predicates</h2>

  <h3 id="like">Like</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">Like</span>(col <span class="typ">string</span>, pattern <span class="typ">string</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>Case-sensitive pattern match using SQL <code>LIKE</code>.</p>

<pre><code>goqdsl.<span class="fn">Like</span>(<span class="str">"email"</span>, <span class="str">"%@example.com"</span>)
<span class="cmt">// email LIKE $N    args: ["%@example.com"]</span></code></pre>

  <h3 id="ilike">ILike</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">ILike</span>(col <span class="typ">string</span>, pattern <span class="typ">string</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>Case-insensitive pattern match (PostgreSQL extension).</p>

<pre><code>goqdsl.<span class="fn">ILike</span>(<span class="str">"name"</span>, <span class="str">"%alice%"</span>)
<span class="cmt">// name ILIKE $N    args: ["%alice%"]</span></code></pre>

  <!-- ── Set ───────────────────────────────────────── -->

  <h2 id="set">Set Predicates</h2>

  <h3 id="in">In</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">In</span>(col <span class="typ">string</span>, vals ...<span class="typ">any</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>
    Checks if a column value is in a set of values. Each value gets
    its own placeholder.
  </p>

<pre><code>goqdsl.<span class="fn">In</span>(<span class="str">"status"</span>, <span class="str">"active"</span>, <span class="str">"pending"</span>, <span class="str">"review"</span>)
<span class="cmt">// status IN ($1, $2, $3)    args: ["active", "pending", "review"]</span></code></pre>

  <h3 id="between">Between</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">Between</span>(col <span class="typ">string</span>, low, high <span class="typ">any</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>Range check using SQL <code>BETWEEN</code>.</p>

<pre><code>goqdsl.<span class="fn">Between</span>(<span class="str">"age"</span>, 18, 65)
<span class="cmt">// age BETWEEN $1 AND $2    args: [18, 65]</span></code></pre>

  <!-- ── Null ──────────────────────────────────────── -->

  <h2 id="null">Null Predicates</h2>

  <h3 id="is-null">IsNull</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">IsNull</span>(col <span class="typ">string</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>Checks if a column is NULL. Consumes no placeholder.</p>

<pre><code>goqdsl.<span class="fn">IsNull</span>(<span class="str">"deleted_at"</span>)
<span class="cmt">// deleted_at IS NULL    args: []</span></code></pre>

  <h3 id="is-not-null">IsNotNull</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">IsNotNull</span>(col <span class="typ">string</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>Checks if a column is not NULL. Consumes no placeholder.</p>

<pre><code>goqdsl.<span class="fn">IsNotNull</span>(<span class="str">"email"</span>)
<span class="cmt">// email IS NOT NULL    args: []</span></code></pre>

  <!-- ── Logical ───────────────────────────────────── -->

  <h2 id="logical">Logical Combinators</h2>
  <p>
    Logical combinators let you compose predicates into complex
    expressions with arbitrary nesting.
  </p>

  <h3 id="and">And</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">And</span>(preds ...<span class="typ">Predicate</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>
    Combines predicates with AND, wrapped in parentheses.
  </p>

<pre><code>goqdsl.<span class="fn">And</span>(goqdsl.<span class="fn">Eq</span>(<span class="str">"a"</span>, 1), goqdsl.<span class="fn">Eq</span>(<span class="str">"b"</span>, 2))
<span class="cmt">// (a = $1 AND b = $2)</span></code></pre>

  <div class="note">
    When you pass multiple predicates to <code>Where()</code> they are
    already ANDed together at the top level. Use the explicit
    <code>And()</code> combinator when you need AND as a sub-expression
    inside an <code>Or()</code>.
  </div>

  <h3 id="or">Or</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">Or</span>(preds ...<span class="typ">Predicate</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>
    Combines predicates with OR, wrapped in parentheses to ensure
    correct precedence.
  </p>

<pre><code>goqdsl.<span class="fn">Select</span>(<span class="str">"*"</span>).<span class="fn">From</span>(<span class="str">"users"</span>).<span class="fn">Where</span>(
    goqdsl.<span class="fn">Or</span>(
        goqdsl.<span class="fn">Eq</span>(<span class="str">"role"</span>, <span class="str">"admin"</span>),
        goqdsl.<span class="fn">Eq</span>(<span class="str">"role"</span>, <span class="str">"superadmin"</span>),
    ),
    goqdsl.<span class="fn">Eq</span>(<span class="str">"active"</span>, <span class="kw">true</span>),
)
<span class="cmt">// WHERE (role = $1 OR role = $2) AND active = $3</span></code></pre>

  <h3 id="not">Not</h3>
  <div class="sig">
    <code><span class="kw">func</span> <span class="fn">Not</span>(pred <span class="typ">Predicate</span>) <span class="typ">Predicate</span></code>
  </div>
  <p>Negates a predicate.</p>

<pre><code>goqdsl.<span class="fn">Not</span>(goqdsl.<span class="fn">Eq</span>(<span class="str">"deleted"</span>, <span class="kw">true</span>))
<span class="cmt">// NOT (deleted = $1)</span></code></pre>

  <!-- ── Nesting ───────────────────────────────────── -->

  <h2 id="nesting">Nesting Example</h2>
  <p>
    Predicates compose arbitrarily. Here is a complex nested expression:
  </p>

<pre><code><span class="cmt">// (a = $1 AND (b = $2 OR c = $3))</span>
pred := goqdsl.<span class="fn">And</span>(
    goqdsl.<span class="fn">Eq</span>(<span class="str">"a"</span>, 1),
    goqdsl.<span class="fn">Or</span>(
        goqdsl.<span class="fn">Eq</span>(<span class="str">"b"</span>, 2),
        goqdsl.<span class="fn">Eq</span>(<span class="str">"c"</span>, 3),
    ),
)

goqdsl.<span class="fn">Select</span>(<span class="str">"*"</span>).<span class="fn">From</span>(<span class="str">"t"</span>).<span class="fn">Where</span>(pred)</code></pre>

  <p class="output-label">Output</p>
  <div class="output">
SQL:  SELECT * FROM t WHERE (a = $1 AND (b = $2 OR c = $3))
Args: [1, 2, 3]
  </div>

  <!-- ── Reference table ──────────────────────────── -->

  <h2 id="reference">Quick Reference</h2>

  <table>
    <thead>
      <tr><th>Category</th><th>Function</th><th>SQL Pattern</th><th>Placeholders</th></tr>
    </thead>
    <tbody>
      <tr><td rowspan="6">Comparison</td><td><code>Eq(col, val)</code></td><td><code>col = $N</code></td><td>1</td></tr>
      <tr><td><code>Neq(col, val)</code></td><td><code>col != $N</code></td><td>1</td></tr>
      <tr><td><code>Gt(col, val)</code></td><td><code>col &gt; $N</code></td><td>1</td></tr>
      <tr><td><code>Gte(col, val)</code></td><td><code>col &gt;= $N</code></td><td>1</td></tr>
      <tr><td><code>Lt(col, val)</code></td><td><code>col &lt; $N</code></td><td>1</td></tr>
      <tr><td><code>Lte(col, val)</code></td><td><code>col &lt;= $N</code></td><td>1</td></tr>
      <tr><td rowspan="2">Pattern</td><td><code>Like(col, pat)</code></td><td><code>col LIKE $N</code></td><td>1</td></tr>
      <tr><td><code>ILike(col, pat)</code></td><td><code>col ILIKE $N</code></td><td>1</td></tr>
      <tr><td rowspan="2">Set</td><td><code>In(col, vals...)</code></td><td><code>col IN ($N, ...)</code></td><td>len(vals)</td></tr>
      <tr><td><code>Between(col, lo, hi)</code></td><td><code>col BETWEEN $N AND $M</code></td><td>2</td></tr>
      <tr><td rowspan="2">Null</td><td><code>IsNull(col)</code></td><td><code>col IS NULL</code></td><td>0</td></tr>
      <tr><td><code>IsNotNull(col)</code></td><td><code>col IS NOT NULL</code></td><td>0</td></tr>
      <tr><td rowspan="3">Logical</td><td><code>And(preds...)</code></td><td><code>(... AND ...)</code></td><td>sum</td></tr>
      <tr><td><code>Or(preds...)</code></td><td><code>(... OR ...)</code></td><td>sum</td></tr>
      <tr><td><code>Not(pred)</code></td><td><code>NOT (...)</code></td><td>inner</td></tr>
    </tbody>
  </table>

</main>
</div>

<footer class="site-footer">
  GoQDSL &mdash; BSD 3-Clause License &mdash; &copy; 2024 Rob Augustinus
</footer>

</body>
</html>
